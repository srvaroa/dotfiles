# ~/.bashrc: executed by bash(1) for non-login shells.
# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)
# for examples

# If not running interactively, don't do anything
[ -z "$PS1" ] && return

# don't put duplicate lines in the history. See bash(1) for more options
# don't overwrite GNU Midnight Commander's setting of `ignorespace'.
HISTCONTROL=$HISTCONTROL${HISTCONTROL+:}ignoredups
# ... or force ignoredups and ignorespace
HISTCONTROL=ignoreboth

# append to the history file, don't overwrite it
shopt -s histappend

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=1000
HISTFILESIZE=2000

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# set variable identifying the chroot you work in (used in the prompt below)
if [ -z "$debian_chroot" ] && [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi

# set a fancy prompt (non-color, unless we know we "want" color)
case "$TERM" in
    xterm-color) color_prompt=yes;;
esac

# uncomment for a colored prompt, if the terminal has the capability; turned
# off by default to not distract the user: the focus in a terminal window
# should be on the output of commands, not on the prompt
force_color_prompt=yes

if [ -n "$force_color_prompt" ]; then
    if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
	# We have color support; assume it's compliant with Ecma-48
	# (ISO/IEC-6429). (Lack of such support is extremely rare, and such
	# a case would tend to support setf rather than setaf.)
	color_prompt=yes
    else
	color_prompt=
    fi
fi

RED="\[\033[0;31m\]"
YELLOW="\[\033[0;33m\]"
MAGENTA="\[\033[0;95m\]"
D_GREEN="\[\033[0;32m\]"
L_GREEN="\[\033[1;32m\]"
BLUE="\[\033[0;34m\]"
NO_COLOUR="\[\033[0m\]"

function git_branch() {
    # bail if no git
    if ! hash git 2> /dev/null ; then
        return
    fi
    # get the branch
    br=`git branch 2> /dev/null | grep -e "^*" | cut -d' ' -f2`
    if [[ ! $br ]] ; then
        return
    fi
    echo " $br"
}

# colour codes the git branch with:
# RED - if deleted files
# LIGHT GREEN - if untracked files
# DARK GREEN - if changes in staged or unstaged files
function git_status_colour() {
    ret=""
    st=`git status --porcelain 2> /dev/null`
    if [[ `echo $st | grep -e "^D"` ]] ; then
        echo -ne ${RED:2:10}
    elif [[ `echo $st | grep -e "^?"` ]] ; then
        echo -ne ${L_GREEN:2:10}
    elif [[ `echo $st | grep -e "^M"` ]] ; then
        echo -ne ${D_GREEN:2:10}
    elif [[ `echo $st | grep -e "^A"` ]] ; then
        echo -ne ${YELLOW:2:10}
    else
        echo -ne ${MAGENTA:2:10}
    fi
}

if [ "$color_prompt" = yes ]; then
    # this below will display a red $ when a command fails
    PROMPT_COMMAND='RET=$?;'
    #RET_COLOR='$(if [[ $RET = 0 ]]; then echo -ne "\e[0;00m"; else echo -ne "\e[0;31m"; fi;)'
    RET_COLOR='$(if [[ $RET = 0 ]]; then echo -ne "\e[0;34m"; else echo -ne "\e[0;31m"; fi;)'
    GIT_COLOR='$(git_status_colour)'
    #PS1="\${debian_chroot:+($debian_chroot)}$D_GREEN\u@$L_GREEN\h:$BLUE\w\[$(git_status_colour)\]\$(git_branch)\[$RET_COLOR\] \$${NO_COLOUR} "
    PS1="\${debian_chroot:+($debian_chroot)}$L_GREEN\h $D_GREEN\u \[$RET_COLOR\]\w\[$(git_status_colour)\]\$(git_branch) ${NO_COLOUR}"
else
    PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w \$(git_branch) \$ '
fi
unset color_prompt force_color_prompt

# If this is an xterm set the title to user@host:dir
case "$TERM" in
xterm*|rxvt*)
    PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w\a\]$PS1"
    ;;
*)
    ;;
esac

# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls -l --color=auto'
    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
else
	alias ls='ls -lG'
fi

# Add an "alert" alias for long running commands.  Use like so:
#   sleep 10; alert
alias alert='notify-send --urgency=low -i "$([ $? = 0 ] && echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'

# vi mode
set -o vi
export EDITOR=vi

# some more ls aliases
alias l='ls -alFh'
alias ll='ls -alFh'
alias la='ls -A'
alias gradle='gradle --daemon'
alias mutt='cd && mutt'

# TODO move this to env. specific files (or make env agnostic)
export JAVA_HOME="/Library/Java/JavaVirtualMachines/jdk1.7.0_10.jdk/Contents/Home/"
export M2_HOME="/usr/local/share/maven/3.1.0"
export M2="$M2_HOME/bin"

export SBT_OPTS="-XX:MaxPermSize=512m -Xms2048m -Xmx2048m"
export MAVEN_OPTS='-XX:MaxPermSize=256m -Xms1024m -Xmx1024m'
export GRADLE_OPTS='-XX:MaxPermSize=256m -Xms1024m -Xmx1024m'
export PATH="/usr/bin:$M2:/usr/local/bin:/usr/local/sbin:$PATH"

export LC_CTYPE=es_ES.UTF-8
export LC_ALL=es_ES.UTF-8

